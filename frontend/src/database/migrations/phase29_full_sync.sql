-- Full System Synchronization Script
-- Run this in Supabase SQL Editor to ensure all tables and columns exist

-- 1. System Config Table
CREATE TABLE IF NOT EXISTS public.system_config (
    key TEXT PRIMARY KEY,
    value JSONB NOT NULL,
    description TEXT,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 2. Unit Types Table (for Master Data Manager)
CREATE TABLE IF NOT EXISTS public.unit_types (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name_ar TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 3. Brands Table (Ensure it exists)
CREATE TABLE IF NOT EXISTS public.brands (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name_ar TEXT NOT NULL,
    logo_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 3b. Sectors Table
CREATE TABLE IF NOT EXISTS public.sectors (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name_ar TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 3c. Areas Table
CREATE TABLE IF NOT EXISTS public.areas (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    sector_id UUID REFERENCES public.sectors(id),
    name_ar TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 3d. Branches Table
CREATE TABLE IF NOT EXISTS public.branches (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    area_id UUID REFERENCES public.areas(id),
    brand_id UUID REFERENCES public.brands(id),
    name_ar TEXT NOT NULL,
    location_lat NUMERIC,
    location_lng NUMERIC,
    google_map_link TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 4. Fault Categories (Ensure it exists)
CREATE TABLE IF NOT EXISTS public.fault_categories (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name_ar TEXT NOT NULL,
    icon TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 4b. Fault Categories Updates (Add missing columns)
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'fault_categories' AND column_name = 'icon') THEN
        ALTER TABLE public.fault_categories ADD COLUMN icon TEXT;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'fault_categories' AND column_name = 'is_active') THEN
        ALTER TABLE public.fault_categories ADD COLUMN is_active BOOLEAN DEFAULT true;
    END IF;
END $$;

-- 5. Profiles Table (Create if not exists)
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID REFERENCES auth.users(id) PRIMARY KEY,
    full_name TEXT,
    email TEXT,
    phone TEXT,
    role TEXT CHECK (role IN ('admin', 'manager', 'technician')) DEFAULT 'technician',
    specialization TEXT,
    assigned_sector_id UUID REFERENCES public.sectors(id),
    assigned_area_id UUID REFERENCES public.areas(id),
    -- branch_id will be added dynamically to match branches.id type
    status TEXT CHECK (status IN ('active', 'suspended')) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 5b. Profiles Updates (Add missing columns if they don't exist)
DO $$ 
DECLARE
    branch_type text;
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'status') THEN
        ALTER TABLE public.profiles ADD COLUMN status TEXT CHECK (status IN ('active', 'suspended')) DEFAULT 'active';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'role') THEN
        ALTER TABLE public.profiles ADD COLUMN role TEXT CHECK (role IN ('admin', 'manager', 'technician')) DEFAULT 'technician';
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'phone') THEN
        ALTER TABLE public.profiles ADD COLUMN phone TEXT;
    END IF;

    -- Dynamic branch_id addition
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'branch_id') THEN
        -- Check the type of branches.id
        SELECT data_type INTO branch_type 
        FROM information_schema.columns 
        WHERE table_name = 'branches' AND column_name = 'id';

        IF branch_type = 'uuid' THEN
            ALTER TABLE public.profiles ADD COLUMN branch_id UUID REFERENCES public.branches(id);
        ELSE
            ALTER TABLE public.profiles ADD COLUMN branch_id TEXT REFERENCES public.branches(id);
        END IF;
    END IF;
END $$;

-- 6. Tickets Table (Create if not exists)
CREATE TABLE IF NOT EXISTS public.tickets (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    -- branch_id added dynamically
    technician_id UUID REFERENCES public.profiles(id),
    status TEXT CHECK (status IN ('open', 'in_progress', 'closed', 'resolved')),
    priority TEXT CHECK (priority IN ('low', 'medium', 'high', 'urgent')),
    fault_category TEXT,
    fault_subcategory TEXT,
    description TEXT,
    images_url TEXT[],
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    form_data JSONB,
    repair_cost NUMERIC DEFAULT 0,
    closed_at TIMESTAMP WITH TIME ZONE,
    category_id UUID REFERENCES public.fault_categories(id),
    start_work_lat NUMERIC,
    start_work_lng NUMERIC,
    end_work_lat NUMERIC,
    end_work_lng NUMERIC
);

-- 6b. Tickets Updates (Add missing columns)
DO $$ 
DECLARE
    branch_type text;
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tickets' AND column_name = 'repair_cost') THEN
        ALTER TABLE public.tickets ADD COLUMN repair_cost NUMERIC DEFAULT 0;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tickets' AND column_name = 'closed_at') THEN
        ALTER TABLE public.tickets ADD COLUMN closed_at TIMESTAMP WITH TIME ZONE;
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tickets' AND column_name = 'category_id') THEN
        ALTER TABLE public.tickets ADD COLUMN category_id UUID REFERENCES public.fault_categories(id);
    END IF;

    -- Dynamic branch_id addition for tickets
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'tickets' AND column_name = 'branch_id') THEN
        -- Check the type of branches.id
        SELECT data_type INTO branch_type 
        FROM information_schema.columns 
        WHERE table_name = 'branches' AND column_name = 'id';

        IF branch_type = 'uuid' THEN
            ALTER TABLE public.tickets ADD COLUMN branch_id UUID REFERENCES public.branches(id);
        ELSE
            ALTER TABLE public.tickets ADD COLUMN branch_id TEXT REFERENCES public.branches(id);
        END IF;
    END IF;
END $$;

-- 7. Ticket Comments
CREATE TABLE IF NOT EXISTS public.ticket_comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ticket_id UUID REFERENCES public.tickets(id),
    user_id UUID REFERENCES public.profiles(id),
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 8. Spare Parts
CREATE TABLE IF NOT EXISTS public.spare_parts (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name_ar TEXT NOT NULL,
    part_number TEXT,
    quantity INTEGER DEFAULT 0,
    price NUMERIC DEFAULT 0,
    minimum_stock INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 9. Inventory Transactions
CREATE TABLE IF NOT EXISTS public.inventory_transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- part_id added dynamically
    ticket_id UUID REFERENCES public.tickets(id),
    user_id UUID REFERENCES public.profiles(id),
    change_amount INTEGER NOT NULL,
    transaction_type TEXT CHECK (transaction_type IN ('restock', 'consumption', 'adjustment', 'return')),
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 9b. Inventory Transactions Updates (Add part_id dynamically)
DO $$ 
DECLARE
    part_type text;
BEGIN 
    -- Dynamic part_id addition for inventory_transactions
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'inventory_transactions' AND column_name = 'part_id') THEN
        -- Check the type of spare_parts.id
        SELECT data_type INTO part_type 
        FROM information_schema.columns 
        WHERE table_name = 'spare_parts' AND column_name = 'id';

        IF part_type = 'uuid' THEN
            ALTER TABLE public.inventory_transactions ADD COLUMN part_id UUID REFERENCES public.spare_parts(id);
        ELSIF part_type = 'text' OR part_type = 'character varying' THEN
            ALTER TABLE public.inventory_transactions ADD COLUMN part_id TEXT REFERENCES public.spare_parts(id);
        ELSE
            ALTER TABLE public.inventory_transactions ADD COLUMN part_id BIGINT REFERENCES public.spare_parts(id);
        END IF;
    END IF;
END $$;

-- Enable RLS on new tables
ALTER TABLE public.system_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.unit_types ENABLE ROW LEVEL SECURITY;

-- Policies for System Config (Admin only usually, but allowing read for now)
CREATE POLICY "Allow read access to system_config" ON public.system_config FOR SELECT USING (true);
CREATE POLICY "Allow full access to admin on system_config" ON public.system_config USING (auth.role() = 'authenticated'); -- Simplified for now

-- Policies for Unit Types
CREATE POLICY "Allow read access to unit_types" ON public.unit_types FOR SELECT USING (true);
CREATE POLICY "Allow insert/update/delete to unit_types" ON public.unit_types USING (auth.role() = 'authenticated');

-- Policies for Brands
CREATE POLICY "Allow read access to brands" ON public.brands FOR SELECT USING (true);
CREATE POLICY "Allow insert/update/delete to brands" ON public.brands USING (auth.role() = 'authenticated');
