-- ========================================================
-- COMPREHENSIVE SYSTEM SETUP (V3 PRO)
-- ========================================================
-- Run this script on a NEW Supabase project to fully initialize the database.
-- It handles Types, Tables, RLS Policies, Triggers, and Default Data.

-- 1. ENUMS
DROP TYPE IF EXISTS user_role CASCADE;
DROP TYPE IF EXISTS ticket_status CASCADE;
DROP TYPE IF EXISTS ticket_priority CASCADE;
DROP TYPE IF EXISTS transaction_type CASCADE;

CREATE TYPE user_role AS ENUM ('admin', 'manager', 'technician');
CREATE TYPE ticket_status AS ENUM ('open', 'in_progress', 'closed', 'resolved');
CREATE TYPE ticket_priority AS ENUM ('low', 'medium', 'high', 'urgent');
CREATE TYPE transaction_type AS ENUM ('restock', 'consumption', 'adjustment', 'return');

-- 2. HIERARCHY & MASTER DATA
CREATE TABLE IF NOT EXISTS public.brands (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name_ar TEXT NOT NULL,
    logo_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.sectors (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name_ar TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.areas (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sector_id UUID REFERENCES public.sectors(id) ON DELETE CASCADE NOT NULL,
    name_ar TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE TABLE IF NOT EXISTS public.branches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    area_id UUID REFERENCES public.areas(id) ON DELETE CASCADE NOT NULL,
    brand_id UUID REFERENCES public.brands(id) ON DELETE CASCADE NOT NULL,
    name_ar TEXT NOT NULL,
    location_lat NUMERIC,
    location_lng NUMERIC,
    google_map_link TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 3. PROFILES (Users)
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    full_name TEXT,
    email TEXT,
    phone TEXT,
    role user_role DEFAULT 'technician' NOT NULL,
    specialization TEXT,
    assigned_sector_id UUID REFERENCES public.sectors(id) ON DELETE SET NULL,
    assigned_area_id UUID REFERENCES public.areas(id) ON DELETE SET NULL,
    branch_id UUID REFERENCES public.branches(id) ON DELETE SET NULL,
    status TEXT CHECK (status IN ('active', 'suspended')) DEFAULT 'active',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 4. SYSTEM CONFIG & METADATA
CREATE TABLE IF NOT EXISTS public.system_config (
    key TEXT PRIMARY KEY,
    value JSONB NOT NULL,
    description TEXT,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS public.unit_types (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name_ar TEXT NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS public.fault_categories (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name_ar TEXT NOT NULL,
    name_en TEXT,
    icon TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS public.sla_policies (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    priority_level TEXT NOT NULL UNIQUE,
    resolution_hours INTEGER NOT NULL DEFAULT 24,
    color_code TEXT NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 5. TICKETS & COMMENTS
CREATE TABLE IF NOT EXISTS public.tickets (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    branch_id UUID REFERENCES public.branches(id) ON DELETE CASCADE NOT NULL,
    technician_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    status ticket_status DEFAULT 'open' NOT NULL,
    priority ticket_priority DEFAULT 'medium' NOT NULL,
    fault_category TEXT,
    category_id UUID REFERENCES public.fault_categories(id),
    fault_subcategory TEXT,
    description TEXT,
    images_url TEXT[] DEFAULT '{}',
    form_data JSONB,
    repair_cost NUMERIC DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    closed_at TIMESTAMP WITH TIME ZONE,
    start_work_lat NUMERIC,
    start_work_lng NUMERIC,
    end_work_lat NUMERIC,
    end_work_lng NUMERIC
);

CREATE TABLE IF NOT EXISTS public.ticket_comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ticket_id UUID REFERENCES public.tickets(id) ON DELETE CASCADE,
    user_id UUID REFERENCES public.profiles(id),
    content TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- 6. INVENTORY
CREATE TABLE IF NOT EXISTS public.spare_parts (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name_ar TEXT NOT NULL,
    part_number TEXT,
    description TEXT,
    quantity INTEGER DEFAULT 0,
    min_threshold INTEGER DEFAULT 5,
    price NUMERIC DEFAULT 0,
    location TEXT,
    supplier TEXT,
    compatible_models TEXT,
    image_url TEXT,
    category_id UUID REFERENCES public.fault_categories(id),
    unit_id BIGINT REFERENCES public.unit_types(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

CREATE TABLE IF NOT EXISTS public.inventory_transactions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    part_id BIGINT REFERENCES public.spare_parts(id) NOT NULL,
    ticket_id UUID REFERENCES public.tickets(id),
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    change_amount INTEGER NOT NULL,
    transaction_type transaction_type NOT NULL,
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now())
);

-- ========================================================
-- SECURITY (RLS)
-- ========================================================
ALTER TABLE brands ENABLE ROW LEVEL SECURITY;
ALTER TABLE sectors ENABLE ROW LEVEL SECURITY;
ALTER TABLE areas ENABLE ROW LEVEL SECURITY;
ALTER TABLE branches ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE ticket_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE system_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE unit_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE fault_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE sla_policies ENABLE ROW LEVEL SECURITY;
ALTER TABLE spare_parts ENABLE ROW LEVEL SECURITY;
ALTER TABLE inventory_transactions ENABLE ROW LEVEL SECURITY;

-- UNIVERSAL READ ACCESS (Simplified for MVP, refine for strict security later)
CREATE POLICY "Public Read Brands" ON brands FOR SELECT USING (true);
CREATE POLICY "Public Read Sectors" ON sectors FOR SELECT USING (true);
CREATE POLICY "Public Read Areas" ON areas FOR SELECT USING (true);
CREATE POLICY "Public Read Branches" ON branches FOR SELECT USING (true);
CREATE POLICY "Public Read Unit Types" ON unit_types FOR SELECT USING (true);
CREATE POLICY "Public Read Categories" ON fault_categories FOR SELECT USING (true);
CREATE POLICY "Public Read SLAs" ON sla_policies FOR SELECT USING (true);
CREATE POLICY "Public Read Config" ON system_config FOR SELECT USING (true);

-- PROFILES
CREATE POLICY "View Own Profile" ON profiles FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Technicians View Area Profiles" ON profiles FOR SELECT USING (
    EXISTS (SELECT 1 FROM profiles me WHERE me.id = auth.uid() AND me.assigned_area_id = profiles.assigned_area_id)
);
CREATE POLICY "Admins Managers View All Profiles" ON profiles FOR SELECT USING (
    EXISTS (SELECT 1 FROM profiles me WHERE me.id = auth.uid() AND me.role IN ('admin', 'manager'))
);

-- TICKETS & COMMENTS
CREATE POLICY "View Tickets" ON tickets FOR SELECT USING (true); -- Refine to area-based later
CREATE POLICY "Create Tickets" ON tickets FOR INSERT WITH CHECK (auth.role() = 'authenticated');
CREATE POLICY "Update Tickets" ON tickets FOR UPDATE USING (auth.role() = 'authenticated');

CREATE POLICY "View Comments" ON ticket_comments FOR SELECT USING (true);
CREATE POLICY "Create Comments" ON ticket_comments FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- INVENTORY
CREATE POLICY "View Inventory" ON spare_parts FOR SELECT USING (true);
CREATE POLICY "Manage Inventory" ON spare_parts FOR ALL USING (
   EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);
CREATE POLICY "View Transactions" ON inventory_transactions FOR SELECT USING (true);
CREATE POLICY "Create Transactions" ON inventory_transactions FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- ========================================================
-- DATA SEEDING (Defaults)
-- ========================================================
INSERT INTO public.unit_types (name_ar) VALUES ('قطعة'), ('لتر'), ('متر'), ('كيلو'), ('علبة') ON CONFLICT DO NOTHING;

INSERT INTO public.sla_policies (priority_level, resolution_hours, color_code)
VALUES 
    ('urgent', 4, '#EF4444'),
    ('high', 12, '#F59E0B'),
    ('medium', 48, '#3B82F6'),
    ('low', 96, '#10B981')
ON CONFLICT (priority_level) DO NOTHING;

-- ========================================================
-- TRIGGERS
-- ========================================================
-- Auto-create profile on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, email, role)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.email, 'technician');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Auto-update stock
CREATE OR REPLACE FUNCTION public.update_part_quantity()
RETURNS trigger AS $$
BEGIN
  UPDATE public.spare_parts
  SET quantity = quantity + new.change_amount,
      updated_at = now()
  WHERE id = new.part_id;
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_inventory_transaction ON public.inventory_transactions;
CREATE TRIGGER on_inventory_transaction
  AFTER INSERT ON public.inventory_transactions
  FOR EACH ROW
  EXECUTE PROCEDURE public.update_part_quantity();
