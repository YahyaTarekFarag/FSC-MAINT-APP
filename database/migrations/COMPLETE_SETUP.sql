-- ========================================================
-- MASTER SCHEMA SETUP (COMPLETE_SETUP.sql)
-- Generated by AI Agent (Antigravity) on 2026-02-17
-- 
-- DESCRIPTION:
-- This script rebuilds the entire database schema from scratch.
-- It combines all previous migrations into a single, ordered execution flow.
-- 
-- ⚠️ WARNING: RUNNING THIS ON AN EXISTING PRODUCTION DB MAY CAUSE DATA LOSS
-- IF "DROP SCHEMA" IS UNCOMMENTED.
-- The script uses "IF NOT EXISTS" to be safe, but review carefully.
-- ========================================================

-- 0. EXTENSIONS
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- 1. ENUMS & TYPES
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
        CREATE TYPE user_role AS ENUM ('admin', 'manager', 'technician');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ticket_status') THEN
        CREATE TYPE ticket_status AS ENUM ('open', 'in_progress', 'closed');
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'ticket_priority') THEN
        CREATE TYPE ticket_priority AS ENUM ('low', 'medium', 'high', 'urgent');
    END IF;
END $$;

-- 2. BASE TABLES (Organization & Profiles)

-- Brands
CREATE TABLE IF NOT EXISTS public.brands (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name_ar TEXT NOT NULL UNIQUE,
    logo_url TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Sectors
CREATE TABLE IF NOT EXISTS public.sectors (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name_ar TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Areas
CREATE TABLE IF NOT EXISTS public.areas (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sector_id UUID REFERENCES public.sectors(id) ON DELETE CASCADE NOT NULL,
    name_ar TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Branches
CREATE TABLE IF NOT EXISTS public.branches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    area_id UUID REFERENCES public.areas(id) ON DELETE CASCADE NOT NULL,
    brand_id UUID REFERENCES public.brands(id) ON DELETE CASCADE NOT NULL,
    name_ar TEXT NOT NULL UNIQUE,
    location_lat DECIMAL(9,6),
    location_lng DECIMAL(9,6),
    google_map_link TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Profiles
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    role user_role DEFAULT 'technician' NOT NULL,
    specialization TEXT,
    assigned_sector_id UUID REFERENCES public.sectors(id) ON DELETE SET NULL,
    assigned_area_id UUID REFERENCES public.areas(id) ON DELETE SET NULL,
    branch_id UUID REFERENCES public.branches(id), -- Added in Phase 29
    status TEXT DEFAULT 'active' CHECK (status IN ('active', 'suspended')), -- Added in Phase 19
    phone TEXT, -- Added in Phase 19
    -- Phase 30 additions
    presence_status TEXT CHECK (presence_status IN ('online', 'busy', 'offline')) DEFAULT 'offline',
    last_activity_at TIMESTAMPTZ,
    current_work_lat NUMERIC,
    current_work_lng NUMERIC,
    
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- 3. SETTINGS & CONFIGURATION

-- System Config (Phase 24)
CREATE TABLE IF NOT EXISTS public.system_config (
    key TEXT PRIMARY KEY,
    value JSONB,
    description TEXT,
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Fault Categories (Phase 27)
CREATE TABLE IF NOT EXISTS public.fault_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name_ar TEXT NOT NULL,
    name_en TEXT,
    icon TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- SLA Policies (Phase 27)
CREATE TABLE IF NOT EXISTS public.sla_policies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    priority_level TEXT NOT NULL UNIQUE,
    resolution_hours INTEGER NOT NULL DEFAULT 24,
    color_code TEXT NOT NULL,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Seed SLA Defaults
INSERT INTO public.sla_policies (priority_level, resolution_hours, color_code)
VALUES 
    ('urgent', 4, '#EF4444'),
    ('high', 12, '#F59E0B'),
    ('medium', 48, '#3B82F6'),
    ('low', 96, '#10B981')
ON CONFLICT (priority_level) DO NOTHING;

-- 4. TICKETS & OPERATIONS

-- Tickets
CREATE TABLE IF NOT EXISTS public.tickets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    branch_id UUID REFERENCES public.branches(id) ON DELETE CASCADE NOT NULL,
    technician_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    status ticket_status DEFAULT 'open' NOT NULL,
    priority ticket_priority DEFAULT 'medium' NOT NULL,
    fault_category TEXT NOT NULL, -- Legacy/Simple text
    category_id UUID REFERENCES public.fault_categories(id), -- Linked Relation
    fault_subcategory TEXT,
    description TEXT,
    images_url TEXT[] DEFAULT '{}',
    
    -- Ops Data
    repair_cost NUMERIC,
    closed_at TIMESTAMPTZ,
    form_data JSONB DEFAULT '{}'::jsonb, -- Dynamic Form Data
    
    -- Location Verification
    start_work_lat FLOAT,
    start_work_lng FLOAT,
    end_work_lat FLOAT,
    end_work_lng FLOAT,

    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Ticket Comments
CREATE TABLE IF NOT EXISTS public.ticket_comments (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ticket_id UUID REFERENCES public.tickets(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- 5. INVENTORY & SPARE PARTS

-- Unit Types
CREATE TABLE IF NOT EXISTS public.unit_types (
    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    name_ar TEXT NOT NULL UNIQUE,
    created_at TIMESTAMPTZ DEFAULT now()
);
INSERT INTO public.unit_types (name_ar) VALUES ('قطعة'), ('لتر'), ('متر'), ('كيلو'), ('علبة') ON CONFLICT (name_ar) DO NOTHING;

-- Spare Parts (V2 Schema)
CREATE TABLE IF NOT EXISTS public.spare_parts (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name_ar TEXT NOT NULL,
  part_number TEXT,
  description TEXT,
  quantity INT DEFAULT 0,
  min_threshold INT DEFAULT 5,
  price DECIMAL(10,2) DEFAULT 0,
  location TEXT,
  supplier TEXT,
  compatible_models TEXT,
  image_url TEXT,
  category_id UUID REFERENCES public.fault_categories(id),
  unit_id BIGINT REFERENCES public.unit_types(id),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Inventory Transactions
CREATE TABLE IF NOT EXISTS public.inventory_transactions (
  id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  part_id BIGINT REFERENCES public.spare_parts(id) ON DELETE CASCADE NOT NULL,
  ticket_id UUID REFERENCES public.tickets(id),
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  change_amount INT NOT NULL,
  transaction_type TEXT CHECK (transaction_type IN ('restock', 'consumption', 'adjustment', 'return')) NOT NULL,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 6. DYNAMIC FORMS & WORKFORCE

-- Category Questions (Active Form Engine)
CREATE TABLE IF NOT EXISTS public.category_questions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    category_id UUID REFERENCES public.fault_categories(id) ON DELETE CASCADE,
    question_text TEXT NOT NULL,
    field_type TEXT NOT NULL CHECK (field_type IN ('text', 'number', 'yes_no', 'photo', 'select')),
    options TEXT[],
    is_required BOOLEAN DEFAULT false,
    stage TEXT DEFAULT 'diagnosis' CHECK (stage IN ('diagnosis', 'closing')),
    order_index INT DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- Area Tech Assignments (Phase 30)
CREATE TABLE IF NOT EXISTS public.area_tech_assignments (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    area_id UUID REFERENCES public.areas(id) ON DELETE CASCADE NOT NULL,
    technician_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    assignment_type TEXT CHECK (assignment_type IN ('primary', 'backup')) DEFAULT 'primary',
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(area_id, technician_id)
);

-- Attendance Logs
CREATE TABLE IF NOT EXISTS public.attendance_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    action_type TEXT NOT NULL CHECK (action_type IN ('check_in', 'check_out')),
    timestamp TIMESTAMPTZ DEFAULT now(),
    location_lat FLOAT,
    location_lng FLOAT,
    device_info TEXT,
    created_at TIMESTAMPTZ DEFAULT now()
);

-- ========================================================
-- RLS POLICIES (Consolidated & Fixed)
-- ========================================================

-- Enable RLS everywhere
ALTER TABLE brands ENABLE ROW LEVEL SECURITY;
ALTER TABLE sectors ENABLE ROW LEVEL SECURITY;
ALTER TABLE areas ENABLE ROW LEVEL SECURITY;
ALTER TABLE branches ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE tickets ENABLE ROW LEVEL SECURITY;
ALTER TABLE system_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE fault_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE sla_policies ENABLE ROW LEVEL SECURITY;
ALTER TABLE spare_parts ENABLE ROW LEVEL SECURITY;
ALTER TABLE inventory_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE category_questions ENABLE ROW LEVEL SECURITY;
ALTER TABLE area_tech_assignments ENABLE ROW LEVEL SECURITY;
ALTER TABLE attendance_logs ENABLE ROW LEVEL SECURITY;

-- Helper Function (Fix Recursion)
CREATE OR REPLACE FUNCTION public.get_my_area_id()
RETURNS UUID AS $$
  SELECT assigned_area_id FROM public.profiles WHERE id = auth.uid();
$$ LANGUAGE sql STABLE SECURITY DEFINER;

-- Profiles Policies
DROP POLICY IF EXISTS "Users can view their own profile" ON profiles;
CREATE POLICY "Users can view their own profile" ON profiles FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Technicians View Area Profiles" ON profiles;
CREATE POLICY "Technicians View Area Profiles" ON profiles FOR SELECT USING (
    public.get_my_area_id() IS NOT NULL AND public.get_my_area_id() = assigned_area_id
);

DROP POLICY IF EXISTS "Admins have full access" ON profiles;
CREATE POLICY "Admins have full access" ON profiles FOR ALL USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role = 'admin')
);

-- Public Read Policies (Metadata)
CREATE POLICY "Public Read Brands" ON brands FOR SELECT TO authenticated USING (true);
CREATE POLICY "Public Read Sectors" ON sectors FOR SELECT TO authenticated USING (true);
CREATE POLICY "Public Read Areas" ON areas FOR SELECT TO authenticated USING (true);
CREATE POLICY "Public Read Config" ON system_config FOR SELECT TO authenticated USING (true);
CREATE POLICY "Public Read FaultCategories" ON fault_categories FOR SELECT TO authenticated USING (true);
CREATE POLICY "Public Read SLAPolicies" ON sla_policies FOR SELECT TO authenticated USING (true);

-- Tickets Policies
CREATE POLICY "Technicians area access" ON tickets FOR ALL USING (
    EXISTS (
        SELECT 1 FROM branches b
        JOIN profiles p ON p.id = auth.uid()
        WHERE b.id = tickets.branch_id
        AND (p.role = 'admin' OR p.assigned_area_id = b.area_id OR p.assigned_sector_id = b.area_id) 
        -- Note: assigned_sector_id check is approximate, strictly should check sector->area
    )
);

-- Inventory Policies
CREATE POLICY "Techs View Parts" ON spare_parts FOR SELECT TO authenticated USING (true);
CREATE POLICY "Admins Manage Parts" ON spare_parts FOR ALL USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);
CREATE POLICY "Techs View Transactions" ON inventory_transactions FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Admins Manage Transactions" ON inventory_transactions FOR ALL USING (
    EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

-- ========================================================
-- FUNCTIONS & TRIGGERS
-- ========================================================

-- Update Part Quantity on transaction
CREATE OR REPLACE FUNCTION public.update_part_quantity()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.spare_parts
  SET quantity = quantity + NEW.change_amount,
      updated_at = now()
  WHERE id = NEW.part_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_inventory_transaction ON public.inventory_transactions;
CREATE TRIGGER on_inventory_transaction
  AFTER INSERT ON public.inventory_transactions
  FOR EACH ROW EXECUTE PROCEDURE public.update_part_quantity();

-- Handle New User (Profile Creation)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, role)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name', 'technician')
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recreate Auth Trigger (Careful with supabase defaults)
-- DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
-- CREATE TRIGGER on_auth_user_created
--   AFTER INSERT ON auth.users
--   FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Enable Realtime
ALTER PUBLICATION supabase_realtime ADD TABLE profiles;
ALTER PUBLICATION supabase_realtime ADD TABLE tickets;

